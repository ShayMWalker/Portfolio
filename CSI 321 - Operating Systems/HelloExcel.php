


<!DOCTYPE html>
<html>
<body>

<?php
/*This is a creation of a library that is incomplete. However, it create functions that will create, write and read the BIFF 8 of an .xls file.
 Do note that this library is far from completion, and is a work in progress. */
//_______________________________________________________________________________________________________________________________________________
/* This first function is not of my own creation and I have provided the link to stackoverflow below.
The purpose of hex_dump is to generte the Hexadecimal values and disply them in an array.
This is needed so that the user can actually see the hexadecimal values through the browser instead of getting odd symbols.
*/
// function from: https://stackoverflow.com/questions/1057572/how-can-i-get-a-hex-dump-of-a-string-in-php
function hex_dump($data, $newline="\n")
{
  static $from = '';
  static $to = '';

  static $width = 16; # number of bytes per line

  static $pad = '.'; # padding for non-visible characters

  if ($from==='')
  {
    for ($i=0; $i<=0xFF; $i++)
    {
      $from .= chr($i);
      $to .= ($i >= 0x20 && $i <= 0x7E) ? chr($i) : $pad;
    }
  }

  $hex = str_split(bin2hex($data), $width*2);
  $chars = str_split(strtr($data, $from, $to), $width);

  $offset = 0;
  foreach ($hex as $i => $line)
  {
    echo sprintf('%6X',$offset).' : '.implode(' ', str_split($line,2)) . ' [' . $chars[$i] . ']' . $newline;
    $offset += $width;
  }
}
//_________________________________________________________________________________________________________________
/* Purpose of this function is to get the binary contents of the file created in Createw and provide the hexadecimal values
 as well as some indicators of bytes leading to the position of the workbook.
*/
function Readb() {
//shortcut to file
$myfile = "file.xls";

/*Systems running Windows differentaite between binary and txt files.
Therefore, the files must be opened with 'b' included in fopen() mode parameter
*/
$file = fopen($myfile,"rb");

/*Retrieves the Binary contents of the file indicated and then reads a portion of the bytes, offset must be included.
Then calls hex_dump so that it can be viewed on the browser.
*/
$magic = stream_get_contents($file, $length = 512, $offset = 0);
hex_dump($magic);
//The logic for this loop is not working properly... will continue to work on.
$dec = 0;
  for($i = 52;$i<=48;$i--){
    $n = ord($magic[$i]);
    $dec = ($dec*256)+$n;
  }
//I'm not not sure about the echo at this point...? Will have to fix this for future versions or for next project. 
echo $dec;


//closing file
fclose($file);
}
//_______________________________________________________________________________________________________________
function Createw(){
/* This fuction creates a new xls file by writing different components in binary/hexidecimal.


Use fopen() to create a new file. If you use on a file that does not exisit it will create
given that the file is opened for writing ("w") or appending ("a").
*/
$newfile = fopen("file.xls", "wb");

/*The first two bytes of the file are (0xD0,0xCF) which is also called the magic bytes.
The magic bytes specifiy the file type, in our case .xls.
Padding is also included within the header block (512 bytes).
In which excel uses many FF or 00 (see Hex editor) to hold blank placeholders.
In the other block of the header I have labeled at the end of lines what the bytes refer to in the best of my ability.
I was following an example written by M.Sabal and will link the example here:
https://elearning.cairn.edu/pluginfile.php/667386/mod_book/chapter/5/msxls.e
*/
$magicBlock = array(0xD0,0xCF,0x11,0xE0,0xA1,0xE1,0x1A,0xE1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3E,0x00,0x03,0x00,0xFE,0xFF,0x09,0x00,
                    0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
                    0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0xFE,0xFF,0xFF,0xFF,
                    0x00,0x00,0x00,0x00,0xFE,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x2F,0x00,0x00,0x00,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
                    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);

$workbookBlock = array(0x19,0x00,0x02,0x00,0x00,0x00,
                       0x09,0x08,0x10,0x00,0x00,0x06,0x05,0x00,0x5A,0x4F,0xCD,0x07, // BIFF 8 and Version Information (workbook)
                       0x31,0x00,0x1E,0x00,0xDC,0x00,0x00,0x00,0x08,0x00,0x90,0x01,0x00,0x00,0x00,0x02,   //Font Calibre
                       0x00,0x37,0x07,0x01,0x43,0x00,0x61,0x00,0x6C,0x00,0x62,0x00,0x72,0x00,0x69,0x00,   //Font Calibre
                       0x0A,0x00,0x00,0x00);   //End of Block (EOF Worksheet Globals)

$worksheetBlock = array(0x09,0x08,0x10,0x00,0x00,0x06,0x10,0x00,0x5A,0x4F,0xCD,0x07, //BIFF 8 and Version Information (worksheet)
                        0x0C,0x00,0x02,0x00,0x64,0x00); //Calcount(not actually sure what this is?))

/*Example from Stack overflow: $string = implode(array_map("chr",$bytes)); Where $bytes is your array of bytes.
chr function converts a byte to a character and the array_map function applies a function to each element in an array,
the implode function joins an array of strings into a single string.
*/
$magicString = implode(array_map("chr",$magicBlock));
$workbookString = implode(array_map("chr",$workbookBlock));
$worksheetString = implode(array_map("chr",$worksheetBlock));

//The IN-BETWEEN or writing through binary directly to the file we just created._____________________________________________________________________________________________________________________
/* In example from  xls_encode_data() in Professor Sabals ex.Code
//I want to find the length of the data for the header.
I also dont want to use the string list excel uses but I want to emmbed the string in to the cell itself...
Helpful Links include:
http://www.idea2ic.com/File_Formats/MICROSOFT%20EXCEL%20FILE%20FORMATxls.pdf
http://www.openoffice.org/sc/excelfileformat.pdf
*/
$InBdataBlock = array(0x04,0x02,//Opcode
                      0x15,0x00, //record length
                      0x00,0x00,0x00,0x00, //Row & Column
                      0xFE,0xFF, // Start String
                      0x0A,0x00, //String length
                      0x48,0x45,0x4C,0x4C,0x4F //The string itself "HELLO"
                      );
$InBdataString = implode(array_map("chr",$InBdataBlock));

//Basis on the Header being in one string altogether (adding in the block above)
$oneString = $magicString.$workbookString.$worksheetString.$InBdataString;

//Write the new string to the file
fwrite($newfile,$oneString);
//close file
fclose($newfile);
}


//_Calling Functions_______________________________________________________________________________________________________

Createw ();
ReadB ();

?>

</body>
</html>
